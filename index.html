<!doctype html>
<!-- 走马灯：全屏文字滚动展示组件，支持横竖屏自适应、点击编辑、本地存储 -->
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>大字灯牌</title>
  <style>
    html,body {
      height: 100%;
      margin: 0;
      background: #000;
      color: #fff;
      -webkit-user-select: none;
      -ms-user-select: none;
      user-select: none;
      touch-action: manipulation;
      overflow: hidden;
      /* add common emoji-capable fonts so emoji render correctly */
      font-family: "Helvetica Neue", Arial, "Noto Color Emoji", "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", sans-serif;
    }

    #viewport {
      position: fixed;
      left: 50%;
      top: 50%;
      transform-origin: center center;
      transform: translate(-50%, -50%) rotate(0deg);
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
      z-index: 1;
    }

    #display {
      position: relative;
      width: 100%;
      height: 100%;
      display:flex;
      align-items:center;
      justify-content:center;
      overflow: hidden;
    }

    #text {
      white-space: nowrap;
      display: inline-block;
      line-height: 1;
      will-change: transform;
      color: #fff;
      background: transparent;
      text-align: center;
      padding: 0 10px;
      box-sizing: content-box;
    }

    #overlay {
      position: absolute;
      inset: 0;
      display: none;
      align-items: center;
      justify-content: center;
      background: rgba(0,0,0,0.5);
      z-index: 20;
    }

    #panel {
      background: #111;
      color: #fff;
      padding: 12px;
      border-radius: 8px;
      width: 90%;
      max-width: 420px;
      box-sizing: border-box;
    }

    #panel label {
      font-size: 14px;
      display:block;
      margin-bottom:6px;
    }

    #inputText {
      width: 100%;
      box-sizing: border-box;
      padding: 8px;
      font-size: 18px;
      border: 1px solid #333;
      border-radius: 4px;
      background: #000;
      color: #fff;
    }

    #buttons {
      margin-top: 8px;
      display:flex;
      gap:8px;
      justify-content:flex-end;
    }

    .btn {
      padding: 8px 12px;
      border-radius: 4px;
      background: #222;
      color: #fff;
      border: 1px solid #333;
      font-size: 16px;
    }
    .btn.primary {
      background: #0b84ff;
      border-color: #0b84ff;
    }

    #hint {
      position: absolute;
      left: 8px;
      top: 8px;
      color: rgba(255,255,255,0.7);
      font-size: 12px;
      z-index: 10;
      background: rgba(0,0,0,0.2);
      padding: 6px 8px;
      border-radius: 6px;
    }
  </style>
</head>
<body>
  <div id="viewport">
    <div id="display">
      <div id="text">hello</div>
    </div>

    <div id="overlay" aria-hidden="true">
      <div id="panel" role="dialog" aria-modal="true">
  <label for="inputText">请输入（最多一行40个字符）：</label>
  <!-- remove maxlength to avoid splitting emoji in the middle; validation uses grapheme clusters -->
  <input id="inputText" type="text" />
        <div id="msg" style="color:#f66;font-size:13px;margin-top:6px;height:18px;"></div>
        <div id="buttons">
          <button id="btnCancel" class="btn">取消</button>
          <button id="btnConfirm" class="btn primary">确认</button>
        </div>
      </div>
    </div>

    <div id="hint">点击屏幕可编辑/暂停</div>
  </div>

  <script>
    (function() {
      const viewport = document.getElementById('viewport');
      const display = document.getElementById('display');
      const textEl = document.getElementById('text');
      const overlay = document.getElementById('overlay');
      const input = document.getElementById('inputText');
      const btnConfirm = document.getElementById('btnConfirm');
      const btnCancel = document.getElementById('btnCancel');
      const msg = document.getElementById('msg');

      let anim = null;
      let isPlaying = true;
      const saved = localStorage.getItem('marqueeText');
      let currentText = saved || 'Love & Peace';

      // Grapheme cluster splitter: uses Intl.Segmenter when available to
      // correctly count and split user-perceived characters (emoji, flags,
      // skin-tone modifiers, combined glyphs). Falls back to Array.from.
      const splitGraphemes = (str) => {
        if (!str) return [];
        if (typeof Intl !== 'undefined' && typeof Intl.Segmenter === 'function') {
          try {
            const seg = new Intl.Segmenter(undefined, { granularity: 'grapheme' });
            return Array.from(seg.segment(str), s => s.segment);
          } catch (e) {
            // fallback below
          }
        }
        // Array.from usually respects astral code points and surrogate pairs
        // which is a reasonable fallback for most cases.
        return Array.from(str);
      };

      /**
       * 设置并启动文字滚动动画
       * @param {string} str - 要显示的文字
       */
      function setTextAndAnimate(str) {
        stopAnimation();
        isPlaying = true;
        currentText = str;

        // 获取旋转后的实际可视宽高
        const rect = viewport.getBoundingClientRect();
        const visualWidth = rect.width;
        const visualHeight = rect.height;
        const isPortrait = visualHeight > visualWidth;
        const fontSize = isPortrait
          ? Math.floor(visualWidth * 0.85)
          : Math.floor(visualHeight * 0.85);

        // 清空 display，准备逐字符渲染
          display.innerHTML = '';
          // 使用 grapheme cluster 切分（确保 emoji/复合字符被当作单个 "字符"）
          const chars = splitGraphemes(str);

        chars.forEach((ch, i) => {
          const el = document.createElement('div');
          el.textContent = ch;
          Object.assign(el.style, {
            position: 'absolute',
            fontSize: fontSize + 'px',
            lineHeight: '1',
            color: '#fff',
            background: 'transparent',
            textAlign: 'center',
            padding: '0',
            boxSizing: 'content-box',
            willChange: 'transform'
          });

          if (isPortrait) {
            // 竖屏：字符水平居中，垂直方向从底部向上错位
            el.style.left = '50%';
            el.style.transform = 'translateX(-50%)';
            const offset = fontSize * i;
            el.style.top = `${visualHeight + offset}px`;
          } else {
            // 横屏：字符垂直居中，水平方向从右侧向左错位
            el.style.top = '50%';
            el.style.transform = 'translateY(-50%)';
            const offset = fontSize * i;
            el.style.left = `${visualWidth + offset}px`;
          }

          display.appendChild(el);

          // 计算动画距离与时长
          const distance = isPortrait
            ? visualHeight + fontSize * (chars.length)
            : visualWidth + fontSize * (chars.length);
          const duration = isPortrait
            ? Math.min(25000, Math.max(3000, Math.round(distance * 5)))
            : Math.min(30000, Math.max(4000, Math.round(distance * 7)));

          // 动画：竖屏向上，横屏向左
          const keyframes = isPortrait
            ? [
                { transform: `translateX(-50%) translateY(0)` },
                { transform: `translateX(-50%) translateY(-${distance}px)` }
              ]
            : [
                { transform: `translateY(-50%) translateX(0)` },
                { transform: `translateY(-50%) translateX(-${distance}px)` }
              ];

          const anim = el.animate(keyframes, {
            duration,
            easing: 'linear',
            fill: 'forwards'
          });
          try {
            anim.play();
          } catch (e) {}

          // 为最后一个字符添加动画结束事件监听，实现循环播放
          if (i === chars.length - 1) {
            // 计算半屏距离，用于提前触发下一轮动画
            const halfDistance = isPortrait ? visualHeight / 2 : visualWidth / 2;
            // 计算触发时机：当最后一个字符移动至半屏位置时
            const triggerTime = duration * ((distance - halfDistance) / distance);
            setTimeout(() => {
              setTextAndAnimate(str);
            }, triggerTime);
          }

          // 暂停/恢复支持
          if (!isPlaying) {
            anim.pause();
          }
        });
      }


      /**
       * 停止所有字符动画
       */
      function stopAnimation() {
        // 遍历所有字符元素，取消动画
        const charEls = display.querySelectorAll('div');
        charEls.forEach(el => {
          const anim = el.getAnimations()[0];
          if (anim) {
            try { anim.cancel(); } catch (e) {}
          }
        });
      }

      /**
       * 暂停当前动画
       */
      function pauseAnimation() {
        const charEls = display.querySelectorAll('div');
        charEls.forEach(el => {
          const anim = el.getAnimations()[0];
          if (anim && isPlaying) {
            try { anim.pause(); } catch (e) {}
          }
        });
        isPlaying = false;
      }

      /**
       * 恢复当前动画
       */
      function resumeAnimation() {
        const charEls = display.querySelectorAll('div');
        charEls.forEach(el => {
          const anim = el.getAnimations()[0];
          if (anim && !isPlaying) {
            try { anim.play(); } catch (e) {}
          }
        });
        isPlaying = true;
      }

      /**
       * 处理屏幕点击事件，暂停动画并打开编辑面板
       * @param {Event} e - 点击事件
       */
      function onBodyTap(e) {
        if (overlay.style.display === 'flex') return;
        pauseAnimation();
        openOverlay();
      }

      /**
       * 打开编辑面板
       */
      function openOverlay() {
        input.value = currentText;
        msg.textContent = '';
        overlay.style.display = 'flex';
        overlay.setAttribute('aria-hidden','false');
        input.focus();
        setTimeout(()=> input.setSelectionRange(input.value.length, input.value.length), 300);
      }
      /**
       * 关闭编辑面板
       */
      function closeOverlay() {
        overlay.style.display = 'none';
        overlay.setAttribute('aria-hidden','true');
      }

      /**
       * 验证用户输入
       * @param {string} s - 输入字符串
       * @returns {Object} - 验证结果 {ok: boolean, reason?: string, normalized?: string}
       */
      function validateInput(s) {
        s = s.replace(/^\s+|\s+$/g, '');
        if (s.length === 0) return { ok:false, reason: '内容不能为空' };
        if (/[\r\n]/.test(s)) return { ok:false, reason: '不允许换行' };
        // 使用 grapheme cluster 计算长度，防止 emoji 被错误计数
        const graphemes = splitGraphemes(s);
        if (graphemes.length > 40) return { ok:false, reason: '最多 40 个字符' };
        // 允许所有可见字符（包括中文、英文、标点）。若需进一步限制可在此扩展。
        return { ok:true, normalized: s };
      }

      btnConfirm.addEventListener('click', () => {
        const val = input.value || '';
        const v = validateInput(val);
        if (!v.ok) {
          msg.textContent = v.reason;
          return;
        }
        msg.textContent = '';
        localStorage.setItem('marqueeText', v.normalized);
        closeOverlay();
        setTextAndAnimate(v.normalized);
      });

      btnCancel.addEventListener('click', () => {
        msg.textContent = '';
        closeOverlay();
        resumeAnimation();
      });

      overlay.addEventListener('click', (ev) => {
        if (ev.target === overlay) {
          msg.textContent = '';
          closeOverlay();
          resumeAnimation();
        }
      });

      document.addEventListener('pointerdown', function(e) {
        if (overlay.style.display === 'flex') return;
        e.preventDefault();
        onBodyTap(e);
      }, {passive: false});

      // 方向处理
      /**
       * 应用旋转角度（当前版本不旋转，仅居中）
       * @param {number} angle - 旋转角度
       */
      function applyRotation(angle) {
        // 不旋转 viewport，或仅保持 translate(-50%,-50%)
        viewport.style.transform = 'translate(-50%,-50%)';
        viewport.style.webkitTransform = 'translate(-50%,-50%)';
      }

      /**
       * 处理屏幕方向变化事件
       */
      function handleOrientationChange() {
        const vw = window.innerWidth;
        const vh = window.innerHeight;
        viewport.style.width = vw + 'px';
        viewport.style.height = vh + 'px';
        // 不旋转 viewport
        applyRotation(0);
        // 等一帧再重建动画，确保尺寸生效
        requestAnimationFrame(() => setTextAndAnimate(currentText));
      }

      /**
       * 设备方向变化回退处理（用于不支持标准 orientation API 的设备）
       * @param {DeviceOrientationEvent} e - 设备方向事件
       */
      function handleDeviceOrientationFallback(e) {
        if (typeof screen.orientation !== 'undefined' || typeof window.orientation === 'number') return;
        const gamma = e.gamma;
        if (gamma == null) return;
        if (gamma > 20) {
          applyRotation(90);
        } else if (gamma < -20) {
          applyRotation(270);
        } else {
          applyRotation(0);
        }
      }

      /**
       * 初始化：绑定事件监听器，启动动画
       */
      function init() {
        // 先检测方向，再渲染文字，确保首次渲染方向正确
        if ('onorientationchange' in window) {
          window.addEventListener('orientationchange', handleOrientationChange);
        }
        if (screen.orientation && screen.orientation.addEventListener) {
          try { screen.orientation.addEventListener('change', handleOrientationChange); } catch(e) {}
        }
        handleOrientationChange();

        window.addEventListener('deviceorientation', handleDeviceOrientationFallback, true);

        document.addEventListener('contextmenu', e => e.preventDefault());
        window.addEventListener('resize', () => {
          setTextAndAnimate(currentText);
          if (!isPlaying) {
            pauseAnimation();
          }
        });
      }

      init();

    })();
  </script>
</body>
</html>
